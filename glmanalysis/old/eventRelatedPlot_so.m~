function eventRelatedPlot_so(view,overlayNum,scan,realX,realY,realS,roi,xBase,yBase,sBase)
% eventRelatedPlot.m
%
%      usage: eventRelatedPlot_so()
%         by: shani, adapted from code by justin gardner
%       date: August 2007
%    purpose: plots the betas and the trial-triggered average for a voxel and surrounding voxels (or surrounding ROI)
%

% get the analysis structure
analysis = viewGet(view,'analysis');
d = analysis.d{scan};
d.r2 = analysis.overlays(1).data{scan};
DM = d.scm;

% select the window to plot into
selectGraphWin;

global MLR;
fignum = MLR.graphFigure;

% turn off menu/title etc.
set(fignum,'NumberTitle','off');
set(fignum,'Name','eventRelatedPlot');

% set roi coords
for roinum = 1:length(roi)
  % get scan coordinates
  roi{roinum}.scanCoords = getROICoordinates(view,roi{roinum},scan);
end

% get current cutoff value
currOverName = viewGet(view,'overlayName');
currOverNum = viewGet(view,'currentOverlay'); % save for later
overlayCutoff = viewGet(view,'overlayMin');
overlayData = analysis.overlays(currOverNum).data{scan};

% get R2 cutoff value (since current overlay may not be R2
viewSet(view,'currentOverlay',1); % r2 is the first overlay
cutoffr2 = viewGet(view,'overlayMin');
viewSet(view,'currentOverlay',currOverNum); % set it back to whatever the current overlay really is

if isempty(d)
  disp('No analysis');
  return
end

% set the group number
groupNum = viewGet(view,'currentGroup');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% plot the hemodynamic response for voxel
% this is really the canonical hrf * the betas for each component
% ** This code also gets the betas which are used 
% later in the model graphing code **
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

figure(fignum), subplot(max(length(roi)+1,2),2,1);
[ehdr time ehdrste] = gethdr(d,realX,realY,realS);
betas = squeeze(d.ehdr(realX,realY,realS,:));

% I don't know what this peak and fit stuff is
if isfield(d,'peak') & isfield(d.peak,'fit') & ~any(isnan(d.peak.amp(realX,realY,realS,:)))
  plotEhdr(time,ehdr,ehdrste,'');
  for r = 1:d.nhdr
    d.peak.fit{realX,realY,realS,r}.smoothX = 1:.1:d.hdrlen;
    fitTime = d.tr*(d.peak.fit{realX,realY,realS,r}.smoothX-0.5);
    plot(fitTime+d.tr/2,d.peak.fit{realX,realY,realS,r}.smoothFit,getcolor(r,'-'));
  end
else
  plotEhdr(time,ehdr,ehdrste);
end
title(sprintf('Voxel (%i,%i,%i): r2=%0.3f, betas = %0.2f, %0.2f, %0.2f, DPI = %0.2f',...
	      xBase,yBase,sBase,analysis.overlays(1).data{scan}(realX,realY,realS),betas(1),betas(2),betas(3), betas(2)/betas(1)));
xaxis(0,max(time));
% add peaks if they exist to the legend
if isfield(d,'stimNames')
  stimNames = d.stimNames;
  if isfield(d,'peak')
    for i = 1:d.nhdr
      stimNames{i} = sprintf('%s: %s=%0.2f',stimNames{i},d.peak.params.method,d.peak.amp(realX,realY,realS,i));
    end
  end
  legend(stimNames);
end

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% if there is an roi at this voxel
% then plot mean (beta*HRF)
%
% If not, then plot the mean response
% of a cube of voxels centered on this voxel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

if(length(roi)==0)
  figure(fignum), subplot(2,2,2);
  ehdr = [];
  count = 0;
  maxVals = MLR.groups(groupNum).scanParams.dataSize;
  for xRange = -2:2 
    x = realX + xRange;
    if x<1 | x>maxVals(1), continue, end % make sure we haven't gone out of the range of the data

    for yRange = -2:2 
      y = realY + yRange;
      if y<1 | y>maxVals(2), continue, end % make sure we haven't gone out of the range of the data

      for sRange = -2:2 
	s = realS + sRange;
	if s<1 | s>maxVals(3), continue, end % make sure we haven't gone out of the range of the data
	
	if (d.r2(x,y,s) >= cutoffr2) & (overlayData(x,y,s) >= overlayCutoff) % only take voxels that have sig r-2 and meet current overlay cutoff
									     % this also restricts the cube to fxnal voxels
	  count = count+1;
	  [ehdr(count,:,:) time] = gethdr(d,x,y,s);
	  multiBetas(count,:) = squeeze(d.ehdr(x,y,s,:));
	end
      
      end
    end
  end
  
  % plot the average of the ehdrs that beat the r2 cutoff
  if count
    plotEhdr(time,squeeze(mean(ehdr)),squeeze(std(ehdr))/sqrt(count));
    Mbetas = mean(multiBetas,1);
    DPI = multiBetas(:,2)./multiBetas(:,1);
    
    title(sprintf('Cube around chosen voxel (n=%i/%i), mean betas= %0.2f %0.2f %0.2f, mean DPI = %0.2f',...
		  count,125, Mbetas(1), Mbetas(2), Mbetas(3), Mbetas(2)/Mbetas(1)), 'Interpreter','none');
  end

else % if there are ROIs
  
  for roinum = 1:length(roi)
    figure(fignum), subplot(length(roi)+1,2,2);
    ehdr = [];
    roin = 0;
    for voxnum = 1:size(roi{roinum}.scanCoords,2)
      x = roi{roinum}.scanCoords(1,voxnum);
      y = roi{roinum}.scanCoords(2,voxnum);
      s = roi{roinum}.scanCoords(3,voxnum);
      if d.r2(x,y,s) >= cutoffr2
	roin = roin+1;
	[ehdr(roin,:,:) time] = gethdr(d,x,y,s);
	multiBetas(roin,:) = squeeze(d.ehdr(x,y,s,:));
      end
    end
    % plot the average of the ehdrs that beat the r2 cutoff
    if roin
      plotEhdr(time,squeeze(mean(ehdr)),squeeze(std(ehdr))/sqrt(size(roi{roinum}.scanCoords,2)));
    end
    Mbetas = mean(multiBetas,1);
    DPI = multiBetas(:,2)./multiBetas(:,1);
    title(sprintf('%s (n=%i/%i), mean betas= %0.2f %0.2f %0.2f, mean DPI = %0.2f', ...
		  roi{roinum}.name,roin,size(roi{roinum}.scanCoords,2), Mbetas(1), Mbetas(2), Mbetas(3), Mbetas(2)/Mbetas(1)), 'Interpreter','none');
  end
end
drawnow;

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%%%%%%%%%%%%%%%
% plot the trial-triggered averages for data and model: For the chosen voxel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%%%%%%%%%%%%%%%

figure(fignum), subplot(max(length(roi)+1,2),2,3)

% load tSeries at chosen voxel
tSeries = percentTSeries(squeeze(loadTSeries(view,scan,realS,[],realX,realY)));

% get trial triggered average
trialTrigSeries = getTrialTrigAvge(tSeries,view,d);

% calculate model
modelSeries = DM*betas; 

% get TTA of model
trialTrigModel = getTrialTrigAvge(modelSeries,view,d); 

% get R-Squared
[rsq res] = calcVarAccnt(trialTrigSeries,trialTrigModel);

% plot
legendHandle(1) = errorbar(-2:2:32,trialTrigSeries(:,1),trialTrigSeries(:,2),'r.-.');
legendStr{1} = 'Data';
hold on
legendHandle(2) = errorbar(-2:2:32,trialTrigModel(:,1),trialTrigModel(:,2),'k.-');
legendStr{2} = 'Model';
xlabel('Volume number');
ylabel('MRI signal');
title(sprintf('Trial-triggered average for Voxel (%i,%i,%i), rSqu = %0.2f',realX,realY,realS,rsq));
legend(legendHandle,legendStr);

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% plot the trial-triggered averages for data and model: for the ROI or cube around the voxel
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%  %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% keyboard % may not want to take the time to do this

if(length(roi)==0)

  figure(fignum), subplot(2,2,4);
  count = 0;
  maxVals = MLR.groups(groupNum).scanParams.dataSize;
  for xRange = -2:2 %-1:1
    x = realX + xRange;
    if x<1 | x>maxVals(1), continue, end % make sure we haven't gone out of the range of the data

    for yRange = -2:2 %-1:1
      y = realY + yRange;
      if y<1 | y>maxVals(2), continue, end % make sure we haven't gone out of the range of the data

      for sRange = -2:2 %-1:1
	s = realS + sRange;
	if s<1 | s>maxVals(3), continue, end % make sure we haven't gone out of the range of the data
	
	if (d.r2(x,y,s) >= cutoffr2) & (overlayData(x,y,s) >= overlayCutoff)
	  count = count+1;
	  % load that voxel's time course
	
	  cubeTseries(:,count) = percentTSeries(squeeze(loadTSeries(view,scan,s,[],x,y)));
	
	end
      end
    end
  end  
  
  % If anything in the cube exceeds the cutoff:
  if(count)
    % get avge time course for the cube:
    cubeTseries = mean(cubeTseries,2);
    
    % get trial triggered average for this avge time course:
    trialTrigCube = getTrialTrigAvge(cubeTseries,view,d);
    
    % calculate the model:
    modelCube = DM*Mbetas'; % the model for the cube is the DM * the avge betas - 
			    % eventually will be better to actually do the GLM on the cube instead of taking avge betas ********* TODO
			    
    % get TTA of the model:				
    trialTrigModCube = getTrialTrigAvge(modelCube,view,d);  
    
    % get R-Squared
    [rsq res] = calcVarAccnt(trialTrigCube,trialTrigModCube);
    
    % plot:
    legendHandle(1) = errorbar(-2:2:32,trialTrigCube(:,1),trialTrigCube(:,2),'r.-.');
    legendStr{1} = 'Data';
    hold on
    legendHandle(2) = errorbar(-2:2:32,trialTrigModCube(:,1),trialTrigModCube(:,2),'k.-');
    legendStr{2} = 'Model';
    xlabel('Volume number');
    ylabel('MRI signal');
    legend(legendHandle,legendStr);
    
    title(sprintf('Trial-triggered average for cube around chosen voxel, Rsqu = %0.2f',rsq))
  end

else % if there are ROIs
  
  for roinum = 1:length(roi)
    figure(fignum), subplot(length(roi)+1,2,(roinum+3));
    ehdr = [];
    % The ROI should already be restricted to relevant voxels, don't do the restriction here
    roiTseries = tseriesROI(view, groupNum, roinum, scan);
    roiTseries = mean(roiTseries{1},2);
    
    % get TTA of ROI tSeries
    trialTrigROI = getTrialTrigAvge(roiTseries,view,d);

    % calculate ROI model
    modelROI = DM*Mbetas'; % the model for the ROI is the DM * the avge betas - 
				 % eventually will be better to actually do the GLM on the ROI instead of taking avge betas ********* TODO
    
    % get TTA of ROI model				 
    trialTrigModROI = getTrialTrigAvge(modelROI,view,d);

    % get R-Squared
    [rsq res] = calcVarAccnt(trialTrigROI,trialTrigModROI);

    % plot
    legendHandle(1) = errorbar(-2:2:32,trialTrigROI(:,1),trialTrigROI(:,2),'r.-.');
    legendStr{1} = 'Data';
    hold on
    legendHandle(2) = errorbar(-2:2:32,trialTrigModROI(:,1),trialTrigModROI(:,2),'k.-');
    legendStr{2} = 'Model';
    xlabel('Volume number');
    ylabel('MRI signal');
    legend(legendHandle,legendStr);

    title(sprintf('Trial-triggered average for %s, Rsqu = %0.2f',roi{roinum}.name,rsq));
    
  end
end
drawnow;

%%%%%%%%%%%%%%%%%%%%%%%%%
% function to plot ehdr
%%%%%%%%%%%%%%%%%%%%%%%%%
function plotEhdr(time,ehdr,ehdrste,lineSymbol)

% whether to plot the line inbetween points or not
if ~exist('lineSymbol','var'),lineSymbol = '-';,end

% and display ehdr
for i = 1:size(ehdr,1)
  if nargin == 2
    h=plot(time,ehdr(i,:),getcolor(i,getsymbol(i,lineSymbol)),'MarkerSize',8);
  else
    h=errorbar(time,ehdr(i,:),ehdrste(i,:),ehdrste(i,:),getcolor(i,getsymbol(i,lineSymbol)),'MarkerSize',8);
  end
  set(h,'MarkerFaceColor',getcolor(i));
  hold on
end
xlabel('Time (sec)');
ylabel('% Signal change');


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% function to get Trial Triggered Average
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function trialTrigSeries = getTrialTrigAvge(tSeries,view,d,cutoff);

if nargin == 3
  cutoff = 6;
end


% the timing is in the analysis structure:
trialStarts = d.stimvol{1};
numTrials = length(d.stimvol{1});
epochTseries = NaN*ones(numTrials,18); % 18 time points = the longest delay period + ITI + 2 volumes before trial start

% need to be able to get stim durations, which requires a little extra coding right now:
% if the scan ended in the middle of the delay period, the first and third components
% won't be aligned, so need to fix that:

numSkips = length(d.stimvol{1})-length(d.stimvol{3}); 
comp1 = d.stimvol{1};
comp3 = NaN*ones(size(comp1));
comp3(1:length(d.stimvol{3})) = d.stimvol{3};
for iSkip = 1:numSkips
  skipInd = find(comp3 - comp1 > 7);
  comp3(skipInd(1)+1:end) = comp3(skipInd(1):end-1);
  comp3(skipInd(1)) = NaN;
end
delayDuration = comp3 - comp1;
numValidTrials = length(find(delayDuration>=cutoff));

% gather the trials with durations above the cutoff
for iTrial = 1:numTrials
  if delayDuration(iTrial)>=cutoff
    startPnt = trialStarts(iTrial)-2;  % *** will need to fix this when cut out junk frames ***
    endPnt = min(startPnt + 17,length(tSeries));
    epochLength = endPnt-startPnt+1;
    epochTseries(iTrial,1:epochLength) = tSeries(startPnt:endPnt);
  end
end

trialTrigSeries(:,1) = nanmean(epochTseries);
trialTrigSeries(:,2) = nanstd(epochTseries)/sqrt(numValidTrials);



return % not going to plot the timecourses anymore
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% plot the timecourse for voxel and ROI
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
figure(fignum), subplot(length(roi)+2,2,3:4)
tSeries = squeeze(loadTSeries(view,scan,realS,[],realX,realY));
legendHandle(1) = plot(tSeries,'k.-');
legendStr{1} = 'TSeries';
xlabel('Volume number');
ylabel('MRI signal');
% and the stimulus times
hold on
axis tight;
if isfield(d, 'stimvol')
  for i = 1:d.nhdr
    vlineHandle = vline(d.stimvol{i},getcolor(i));
    legendHandle(i+1) = vlineHandle(1);
    nStimvol(i) = length(d.stimvol{i});
    if isfield(d,'stimNames')
      legendStr{i+1} = sprintf('%s (n=%i)',d.stimNames{i},nStimvol(i));
    else
      legendStr{i+1} = sprintf('%i (n=%i)',i,nStimvol(i));
    end
  end
end
legend(legendHandle,legendStr);

for roinum = 1:length(roi)
  figure(fignum), subplot(length(roi)+2,2,(roinum+4):(roinum+5));
  roiTseries = tseriesROI(view, groupNum, roinum, scan);
  roiTseries = mean(roiTseries{1},2);
  legendHandle(1) = plot(roiTseries,'k.-');
  legendStr{1} = 'TSeries';
  xlabel('Volume number');
  ylabel('MRI signal');
  % and the stimulus times
  hold on
  axis tight;
  if isfield(d, 'stimvol')
    for i = 1:d.nhdr
      vlineHandle = vline(d.stimvol{i},getcolor(i));
      legendHandle(i+1) = vlineHandle(1);
      nStimvol(i) = length(d.stimvol{i});
      if isfield(d,'stimNames')
	legendStr{i+1} = sprintf('%s (n=%i)',d.stimNames{i},nStimvol(i));
      else
	legendStr{i+1} = sprintf('%i (n=%i)',i,nStimvol(i));
      end
    end
  end
  legend(legendHandle,legendStr);
  title(sprintf('T series for ROI %s',roi{roinum}.name));
end
